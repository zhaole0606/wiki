---
title: 基础-原码，反码，补码
description: 
published: true
date: 2024-03-05T09:04:17.004Z
tags: 
editor: markdown
dateCreated: 2024-03-05T08:53:45.287Z
---

## 零散知识点
计算器是没法做减法，因为计算机只有累加器，减法也是加上这个数的相反数，所以需要存在一个符号位表示正负，0表示正数，1表示负数。
原码，补码，反码的存在就是为了解决计算机做减法时候符号的问题。

## 原码
最直观的二进制展示方式，最高位是符号位。
**原码的问题有三个：**
1. 有正负零的问题$0000,0000$和$1000,0000$
2. 如果按照原码直接计算会可能会出现问题。如下面例子，做正数相加并不会出现问题，但是遇到了负数就会出问题，主要也是由符号位引起。==符号位无法参与运算==
  
   >$0001+0010=0011,1+2=3$
   {.is-success}
   
   >$0001+1001=1010,1+(-1)=-2$ //错误 
   {.is-danger}
  
3. 原码表示加减运算比较复杂
    >利用原码进行两数相加运算时，首先要判别两数符号，同号加法，异号减法。在利用原码进行两数相减运算时，不仅要判别两数符号，使得同号相减，异号相加；还要判别两数绝对值的大小，用绝对值大的数减去绝对值小的数，取绝对值大的数的符号为结果的符号。

## 反码
原码有个问题是相反的两个数相加不为0，反码为了解决负数的问题。
反码表示的方式是==正数保持不变，负数除了符号位其他位取反==。
> $0011_{反}+1011_{反} = 1110_{反} =1001，3+(-4)= -1$
{.is-success}

> $0001_{反}+1110_{反} = 1111_{反} =1000，1+(-1)= -0$  //错误 
> $1110_{反} + 1100_{反} = 1010_{反} = 1101，  (-1)+(-3) =-5$  //错误 
{.is-danger}


互为相反数的两个数相加是-0，而且两个负数相加也错了。反码并没有解决我们的问题。

## 补码
正数的补码保持不变，负数的补码是反码+1。但有一点要注意，补码=反码+1只是它的求法，而不是补码的定义。
补码的定义可以从生活中找到同等类比。
>当前是8点，如果要将时钟拨到6点有两种方式
>往回拨2小时到6点，8-2=6；
>往后拨10小时到6点，8+(4+6)=18；

对于时钟来说超过12点后又重新计算，这个12就是时钟的==模==。
对于模为12的时钟来说，8-2和8+10是等效的，结果都在6这个位置，8和10就是==同余数==

>**什么是“模”**
>模是一个计量系统的技术范围 ，它的值在计量器上表示不出来，计量器只能表示模的余数。
>对应到n位计算机，它的计量范围是$0 至(2^{n}-1)$，模就是$2^{n}$
>
>**什么是“同余”**
>两个整数a，b，若它们除以整数m所得的余数相等，则称a，b对于模m同余。
>当m =12 ，8mod12 == 10mod12，8和12就是同余数。

反码表示法中，我们把减法化为加法的思维是减去一个数等于加上这个数的相反数，但引入符号位造成了各种意想不到的问题。
但是从补码的例子中可以看出：对于数值有限制、有溢出的运算（模运算）来说，减去一个数，其实也相当于加上这个数的同余数。
补码解决了计算机减法转化为加法的难题，使得减去一个数，变为加上那个数的补码。

==**计算机中所有的存储和计算都是根据补码的形式来**==

把上面模和同余数的概念带入到计算机中，比如一个4位的二进制地址，它能表示的最大数（模）是$2^{4}=16$ 。
现在要进行运算5-2，对于减2相当加上它的同余数也就是16-2=14。现在5-2=>5+14=19。
再转换为二进制 $5_{10}=0101_{2}，14_{10}=1110_{2} ，0101_{2}+1110_{2}=10011_{2}=19_{10}$，此时的二进制还是补码形式。

>为什么补码是反码+1?
>（原码+反码+1=模） && （补码+原码=模） => ==补码 = 反码+1==  => ==补码的原码 = 取反 - 1 ==

继续将$10011_{2}$转换成原码，由于只有四位所以忽略首位，$0011_{2}=>1100_{2}=>1100_{2}-1=0011_{2}=3_{10}$。

一个八位的二进制，最大能表示的整数是255，如果是有符号整形表示的范围是==-128~127==,补码范围是0~256。那么问题来了，这个-128是从何处来的？在文章前面提到原码和反码有个问题就是正负零问题，在补码中则不会有这个问题，0的二进制0000,0000，那么1000,0000是什么?

> 计算下(-1)+(-127)
>    1 1111111 补  +
>    1 0000001 补 
>   \----------------------
>    1 0000000 补
{.is-info}




得出的结果转换成原码是0000,0000，这下就有问题了，0000,0000既要表示0又要表示-128？

正数范围：0000 0000 - 0111 1111 ；0 ~ +127（原码）
负数范围：1000 0001 - 1111 1111 ；-1 ~ -127（原码）
正数补码范围：0000 0000 - 0111 1111； 0 ~ +127（补码）
负数补码范围：1111 1111 – 1000 0001； -1 ~ -127（补码）

于是就有了规定1000 0000定为-128的补码，并且-128没有原码和反码。

补码解决的问题：
1. 补码解决了计算机减法转化为加法的难题，使得减去一个数，变为加上那个数的补码。
2. 补码解决了+0和-0的问题。
3. 补码解决了符号位不能参与运算的问题，这非常关键。
4. 补码也使得我们多了1位来表示-128。

## 无符号与有符号数转换
一个8位的二进制，无符号位最大能表示的范围是0\~255，有符号位的范是-128~127。
在实际应用中二者如何转换的？比如在8086CPU中计算跳转指令的偏移等等。现在就用三个例子来说明它们之间是如何转换的。
### 无符号数转有符号(正数)
将无符号数7F转换为有符号数，先进行如下进制转换。$7F_{16}=127_{10}=0111,1111_{2}$，
1. 二进制最高位是符号位，0表示正数，1表示负数。7F转换成二进制后通过符号位我们知道这个数是正数。
2. 7F的十进制是127。它的十进制数是在0-127范围内。
4. 所以7F的补码是本身，有符号位数就是本身。
### 无符号数转有符号(负数)
将无符号数F7转换为有符号数，先进行如下进制转换$F7_{16}=247_{10}=1111,0111_{2}$
1. F7转换成二进制发现最高位是1也就是说这个数是负数。
1. F7换成十进制也是247，范围在0~512以内但不在正数范围内。所以要对它求补码。
2. **补码的计算方法是将绝对值的二进制形式取反再加 1**。二进制取绝对值很简单就是首位1变0。$1111,0111_{2} => 0111,0111_{原码} =  1000,1001_{补码}= -9_{10}$
3. 所以无符号书F7转变成符号数的十进制就是-9。

### 有符号数转无符号数(负数)
1. 首先确定符号数的表示范围。然后再看正负。
2. 如果是正数，则转换的值与原值相同。
3. 如果是负数，则直接**原码+256**就是对应的无符号表示形式。如果是-9，则用-9+256 = 247。

>无符号也是可以直接计算出来。比如上面的F7转换十进制是247。已经知道它是负数。用**原码-256** = -9
{.is-info}

## 资料引用
[计算机组成原理：如何计算数据（数学理论](https://zhuanlan.zhihu.com/p/568263996)
[二进制的原码、反码、补码](https://zhuanlan.zhihu.com/p/99082236)
 